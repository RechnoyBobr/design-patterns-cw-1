# Банковское приложение с использованием паттернов проектирования

## Описание проекта
Данный проект представляет собой банковское приложение, реализованное с использованием различных паттернов проектирования. Приложение позволяет управлять банковскими счетами, операциями и категориями транзакций.

## Использованные паттерны проектирования

### 1. Паттерн Команда (Command)
- **Реализация**: Классы в пакете `cmd`
- **Основные компоненты**:
  - `Command` - интерфейс команды
  - `CreateCmd`, `GetCmd`, `DeleteCmd` - конкретные команды
  - `CommandFacade` - инициатор команд
  - `BankFacade` - высокоуровневый интерфейс для работы с командами
- **Преимущества**:
  - Инкапсуляция запросов в виде объектов
  - Возможность поддержки отмены операций
  - Разделение отправителя и получателя запроса

### 2. Паттерн Декоратор (Decorator)
- **Реализация**: Класс `CommandDecorator`
- **Применение**: Добавление дополнительной функциональности к командам (логирование, валидация)
- **Преимущества**:
  - Динамическое добавление поведения к объектам
  - Соблюдение принципа открытости/закрытости
  - Возможность комбинирования различных декораторов

### 3. Паттерн Фабрика (Factory)
- **Реализация**: Фабрики в пакете `factories`
- **Применение**: Создание объектов различных типов (счета, операции, категории)
- **Преимущества**:
  - Инкапсуляция логики создания объектов
  - Возможность создания семейств связанных объектов
  - Упрощение добавления новых типов объектов

### 4. Шаблонный метод (Template Method)
- **Реализация**: Классы импортеров и экспортеров
- **Применение**: 
  - Базовый интерфейс `BaseImporter` и `BaseExporter`
  - Конкретные реализации для CSV, JSON и YAML форматов
- **Преимущества**:
  - Переиспользование кода
  - Определение алгоритма в базовом классе
  - Возможность переопределения шагов в подклассах

### 5. Паттерн Посетитель (Visitor)
- **Реализация**: В классах импортеров и экспортеров
- **Применение**: Обработка различных типов данных при импорте/экспорте
- **Преимущества**:
  - Добавление новых операций без изменения классов
  - Разделение алгоритмов и структур данных
  - Упрощение добавления новых форматов

## Принципы SOLID

### 1. Single Responsibility Principle (SRP)
- Каждый класс имеет одну ответственность
- Примеры:
  - `CommandFacade` отвечает только за выполнение команд
  - `BankFacade` предоставляет высокоуровневый интерфейс
  - Импортеры/экспортеры отвечают только за работу с конкретным форматом

### 2. Open/Closed Principle (OCP)
- Классы открыты для расширения, закрыты для модификации
- Примеры:
  - Добавление новых команд без изменения существующих
  - Добавление новых форматов импорта/экспорта
  - Расширение функциональности через декораторы

### 3. Liskov Substitution Principle (LSP)
- Объекты базовых классов могут быть заменены объектами подклассов
- Примеры:
  - Все команды могут быть использованы через `CommandFacade`
  - Все импортеры/экспортеры взаимозаменяемы

### 4. Interface Segregation Principle (ISP)
- Интерфейсы специфичны для клиентов
- Примеры:
  - `BaseImporter` и `BaseExporter` разделены
  - Специфичные интерфейсы для разных типов операций

### 5. Dependency Inversion Principle (DIP)
- Зависимости от абстракций, а не от конкретных реализаций
- Примеры:
  - Использование интерфейсов для команд
  - Внедрение зависимостей через Spring

## Принципы GRASP

###  Low Coupling
- Минимизация зависимостей между классами
- Примеры:
  - Использование интерфейсов
  - Внедрение зависимостей
  - Разделение ответственности

###  High Cohesion
- Классы имеют четкую, сфокусированную ответственность
- Примеры:
  - Специализированные импортеры/экспортеры
  - Отдельные классы для разных типов команд
